# Automation Script Generation

The `automation_script_gen` package is responsible for generating automation script parts. The functions allow the creation of Python scripts that are modeled on automations from configuration files.

It consists of multiple scripts, each contributing to a specific part of the automation process. The `util.py` script is used to initialize the main script and provides a general function for writing to the created script. This function can be used by other scripts in the package to write their respective automation code to the automation script. By organizing the automation code into separate scripts, it becomes easier to manage and maintain the automation process.

## Script Generation

### General Structure

A generated automation script consists of 5 sections:

- Warning comment, import and global variables,
- `trigger_check` function
- `condition_evaluation` function
- `action_execution` function
- `run_if_main` funciton

The input value list for using the generated script should look like this:

```python
input_vals = [[trigger_inputs],[condition_inputs],[action_inputs]]
```

---

### Templates

In order to transfer the consistent structures of automations into the generated scripts, templates are used for the majority of the code to be generated. Like this every generated automation script starts with the following lines and it can be ensured that no problems occur in individual lines during generation

`./template/init_template.py`

```python
    """
    WARNING: This file was generated by the automation_script_gen module.
            Changes to this file may alter the automation flow or prevent the repeatability of a test run.

    Please only change this file if you know what you are doing.
    """

    import sys
    import json

    # read the arguments
    serialized_inputs = sys.argv[1]

    input_vals = json.loads(serialized_inputs)

    trigger_id: str = None


    def trigger_check(input_vals) -> bool:
        triggered = False
        trigger = input_vals[0]
        global trigger_id
```

These templates are then integrated as follows.

```python
    init_template = path.join(TEMPLATE_PATH, "init_template.py")
    try:
        with open(init_template, "r") as file:
            script_content = file.read()
    except FileNotFoundError:
        raise FileNotFoundError(f"Template file {init_template} not found")

    # ! tabs aren't taken into account and are converted to 4 spaces
    script_content = script_content.replace("    ", "\t")

    append_script_context_to_script(filepath, script_content)
```

---

### Generated Code

The main functions for transferring the variable logic of the automations into the automation script are implemented in the `create_(trigger)_script` or `create_combined_(trigger)_script` functions. In these functions, the for example trigger condition is created for individual trigger entities in the automation script.

The other functions extend the structure with, for example, logic blocks and thus enable the creation of complex structures in the various sections within an automation.

## Usage

To use the script generation package, follow these steps:

1. Import the necessary modules:

```python
import backend.automation_script_gen as asg
```

2. Initialize the automation script:

```python
automation_name = automation_config.automation_name
automation_script = asg.init_automation_script(automation_name)
```

### Trigger

Because the trigger function is contained in the `init_template.py`, it does not require start initialization of the trigger block.

```python
    def trigger_check(input_vals) -> bool:
     triggered = False
     trigger = input_vals[0]
     global trigger_id
```

Generate the trigger parts depending on the `trigger_type`, `position`, `trigger_id`, `indentation_level` and if its combined or not:

```python
# create the script for the combination of the event trigger
real_position = asg.create_combination_trigger_script(
    trigger_type=CONF_EVENT,
    entity_list=new_entity_list,
    trigger_pos=real_position,
    trigger_id=trigger_id,
    filepath=script_path,
    indentation_lvl=indentation_level,
    source=source,
)

# create the script for a single entity in the event_type part
real_position = asg.create_trigger_script(
    trigger_type=CONF_EVENT,
    entity=entity,
    trigger_pos=real_position,
    trigger_id=trigger_id,
    filepath=script_path,
    indentation_lvl=indentation_level,
    source=source,
)
```

This functions leading to generated code like the following. In this example, a state entity was created and a query was generated in the script that checks whether the state would cause a trigger

```python
    if (trigger[0] is not None and (trigger[0] == "off")):
      trigger_id = None
      triggered = True
```

The trigger block is closed with the `close_trigger_section(filepath)` function and this adds the return of the `triggered` value to the block.

```python
 # The end of the trigger section
 return triggered
```

### Condition

To insert the conditions the `condition_evaluation` function has to be initialized.

```python
asg.init_condition_part(script_path)
```

This generates the following code in the script, which allows the addition of conditions.

```python
    def condition_evaluation(input_vals) -> dict:
        condition = input_vals[1]
        if condition != [] and None in condition:
            return print(json.dumps({"ValueError": "Condition values cannot be None"}))

        condition_passed = False

        if (
```

Except for the first, each conditional block is connected with `and`, which means that each block must be `true` for the conditional function to `return true`.

Condition parts can be added to the condition block with the following functions. The attributes are similar to those used when creating a trigger, with the exception of `first_element`, since it now makes a difference whether a condition is generated first or not.

```python
# create a block of conditions which all have to be true
real_position = asg.create_combination_condition_script(
    CONF_NUMERIC_STATE,
    new_entity_list,
    real_position,
    script_path,
    indentation_lvl=indentation_level,
    first_element=first_element,
    source=source,
    combinator=combinator,
)

# create a single condition 
real_position = asg.create_condition_script(
    CONF_NUMERIC_STATE,
    new_entity_list[0],
    real_position,
    script_path,
    indentation_lvl=indentation_level,
    first_element=first_element,
    source=source,
    combinator=combinator,
)
```

The functions are then used to create the following condition in the automation script, for example. This checks whether an entity is in a certain state.

```python
     (condition[0] == "on")

```

When all conditions have been inserted, the script is closed with the `close_condition_section` function as follows.

```python
    ):
        condition_passed = True
    # The end of the condition section
    return condition_passed
```

### Actions

To insert the actions the `action_execution` function has to be initialized.

```python
asg.init_action_part(script_path)
```

This generates the following code in the script, which allows the addition of actions or other action block.

```python
    def action_execution(input_vals) -> None:
     action_inputs = input_vals[2]
     action_results = []
    
     if action_inputs != [] and None in action_inputs:
      return print(json.dumps({"ValueError": "Action input values cannot be None"}))
```

Then different action blocks can be added with the different functions from `action_script_gen.py`.

With `create_action_script` you can create different outputs, which are added to the `action_results`. This list is returned at the end of the function and then printed in the main to be returned to the calling script or the console.

```python
    action_results.append({'media_player.living_room':'media_pause'})

 # The end of the action section
 print(json.dumps(action_results))

if __name__ == "__main__":
 if trigger_check(input_vals):
  if condition_evaluation(input_vals):
   action_execution(input_vals)

```

## Example generated Code

```python
"""
WARNING: This file was generated by the automation_script_gen module.
   Changes to this file may alter the automation flow or prevent the repeatability of a test run.

Please only change this file if you know what you are doing.
"""

import sys
import json

# read the arguments
serialized_inputs = sys.argv[1]

input_vals = json.loads(serialized_inputs)

trigger_id: str = None


def trigger_check(input_vals) -> bool:
 triggered = False
 trigger = input_vals[0]
 global trigger_id
 if (trigger[0] is not None and (trigger[0] == "off")):
  trigger_id = None
  triggered = True

 if (trigger[1] is not None and (trigger[1] == "off")):
  trigger_id = None
  triggered = True

 # The end of the trigger section
 return triggered

def condition_evaluation(input_vals) -> dict:
 condition = input_vals[1]
 if condition != [] and None in condition:
  return print(json.dumps({"ValueError": "Condition values cannot be None"}))

 condition_passed = False

 if (
  (condition[0] == "on")
 ):
  condition_passed = True
 # The end of the condition section
 return condition_passed

def action_execution(input_vals) -> None:
 action_inputs = input_vals[2]
 action_results = []
  
 if action_inputs != [] and None in action_inputs:
  return print(json.dumps({"ValueError": "Action input values cannot be None"}))

 action_results.append({'light.main_light_living_room':'turn_off'})

 if not (
  (action_inputs[0] == "playing")
 ):
  print(json.dumps(action_results))
  return

 action_results.append({'media_player.living_room':'media_pause'})


 # The end of the action section
 print(json.dumps(action_results))

if __name__ == "__main__":
 if trigger_check(input_vals):
  if condition_evaluation(input_vals):
   action_execution(input_vals)
```
